<!DOCTYPE html>
<html>
<head>
    <title>CRUD Tables</title>
    <style>
        /* Your existing CSS */
    </style>
</head>
<body>
    <h2>Publishers</h2>
    <table>
        <thead>
            <tr>
                <th>Publisher ID</th>
                <th>Publisher Name</th>
                <th>Email</th>
                <th>Phone</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody id="publisherTableBody"></tbody>
    </table>

    <h2>Subjects</h2>
    <table>
        <thead>
            <tr>
                <th>Subject ID</th>
                <th>Subject Name</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody id="subjectTableBody"></tbody>
    </table>

    <h2>Authors</h2>
    <table>
        <thead>
            <tr>
                <th>Author ID</th>
                <th>Author Name</th>
                <th>Email</th>
                <th>Phone</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody id="authorTableBody"></tbody>
    </table>

    <h2>Titles</h2>
    <table>
        <thead>
            <tr>
                <th>Title ID</th>
                <th>Title</th>
                <th>Publisher ID</th>
                <th>Subject ID</th>
                <th>Publication Date</th>
                <th>Cover</th>
                <th>Price</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody id="titleTableBody"></tbody>
    </table>

    <script>
        const tableConfigs = {
            publishers: {
                endpoint: '/publishers',
                tableBodyId: 'publisherTableBody',
                fields: [
                    { key: 'pubID', type: 'number', label: 'Publisher ID' },
                    { key: 'pname', type: 'text', label: 'Publisher Name' },
                    { key: 'email', type: 'email', label: 'Email' },
                    { key: 'phone', type: 'tel', label: 'Phone' }
                ]
            },
            subjects: {
                endpoint: '/subjects',
                tableBodyId: 'subjectTableBody',
                fields: [
                    { key: 'subID', type: 'text', label: 'Subject ID' },
                    { key: 'sName', type: 'text', label: 'Subject Name' }
                ]
            },
            authors: {
                endpoint: '/authors',
                tableBodyId: 'authorTableBody',
                fields: [
                    { key: 'auID', type: 'number', label: 'Author ID' },
                    { key: 'aName', type: 'text', label: 'Author Name' },
                    { key: 'email', type: 'email', label: 'Email' },
                    { key: 'phone', type: 'tel', label: 'Phone' }
                ]
            },

            titles: {
                endpoint: '/titles',
                tableBodyId: 'titleTableBody',
                fields: [
                    { key: 'titleID', type: 'number', label: 'Title ID' },
                    { key: 'title', type: 'text', label: 'Title' },
                    { key: 'pubID', type: 'number', label: 'Publisher ID' },
                    { key: 'subID', type: 'text', label: 'Subject ID' },
                    { key: 'pubDate', type: 'date', label: 'Publication Date' },
                    { key: 'cover', type: 'text', label: 'Cover' },
                    { key: 'price', type: 'number', label: 'Price' }
                ]
            }

        };
        function createEditableCell(endpoint, ID, field, value) {
            return `
                <td>
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <span class="display-text">${value}</span>
                        <input class="edit-input" type="text" value="${value}" style="display: none;"
                            data-endpoint="${endpoint}" data-id="${ID}" data-field="${field}"
                            onblur="finishEdit(this)" onkeydown="handleKey(event, this)">
                        <button class="edit-btn" onclick="startEdit(this)" 
                            style="background: none; border: none; cursor: pointer;">✏️</button>
                    </div>
                </td>
            `;
        }

        function startEdit(button) {
            const td = button.closest('td');
            td.querySelector('.display-text').style.display = 'none';
            const input = td.querySelector('.edit-input');
            input.style.display = 'inline';
            input.focus();
        }

        function finishEdit(input) {
            const td = input.closest('td');
            const newValue = input.value.trim();
            td.querySelector('.display-text').textContent = newValue;
            td.querySelector('.display-text').style.display = 'inline';
            input.style.display = 'none';
            updateCell(input.dataset.endpoint, input.dataset.id, input.dataset.field, newValue);
        }

        function handleKey(event, input) {
            if (event.key === 'Enter') {
                input.blur();
            } else if (event.key === 'Escape') {
                const td = input.closest('td');
                input.value = td.querySelector('.display-text').textContent;
                input.style.display = 'none';
                td.querySelector('.display-text').style.display = 'inline';
            }
        }

        async function updateCell(endpoint, ID, field, value) {
            const res = await fetch(`${endpoint}/${ID}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ field, value })
            });
            if (!res.ok) alert('Failed to update.');
        }

        async function fetchAndRenderTable(endpoint, tableBodyId, fields) {
            const res = await fetch(endpoint);
            const data = await res.json();
            const tbody = document.getElementById(tableBodyId);
            tbody.innerHTML = '';

            data.forEach(item => {
                const row = document.createElement('tr');
                row.innerHTML = fields.map(f =>
                    createEditableCell(endpoint, item[fields[0].key], f.key, item[f.key] || '')
                ).join('');

                const actionCell = document.createElement('td');
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.onclick = () => deleteItem(endpoint, item[fields[0].key], () => fetchAndRenderTable(endpoint, tableBodyId, fields));
                actionCell.appendChild(deleteBtn);

                row.appendChild(actionCell);
                tbody.appendChild(row);
        });


            const inputRow = document.createElement('tr');
                inputRow.innerHTML = fields.map(f =>
                    `<td><input type="${f.type}" data-entity="${tableBodyId}" data-key="${f.key}" placeholder="${f.label}" /></td>`
                ).join('') + `<td><button class="add-btn" data-entity="${tableBodyId}">Add</button></td>`;
                tbody.appendChild(inputRow);
        }


        async function deleteItem(endpoint, id, refreshFn) {
            if (!confirm(`Delete item ${id}?`)) return;
            const res = await fetch(`${endpoint}/${id}`, { method: 'DELETE' });
            if (res.ok) refreshFn();
            else alert('Failed to delete item.');
        }

        async function addItem(endpoint, fields, fetchFunction) {
            const itemData = {};

            // Extract values from input fields
            for (const field of fields) {
                const element = document.getElementById(field);
                if (element) {
                    itemData[field] = element.value.trim();
                }
            }

            const res = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(itemData),
            });

            if (res.ok) {
                fetchFunction(); 
            } else {
                alert(`Failed to add item to ${endpoint}.`);
            }
        }

        document.addEventListener('click', async function (e) {
            if (!e.target.classList.contains('add-btn')) return;

            const tableBodyId = e.target.dataset.entity;
            const config = Object.values(tableConfigs).find(cfg => cfg.tableBodyId === tableBodyId);
            if (!config) return;

            const { endpoint, fields } = config;
            const itemData = {};

            fields.forEach(f => {
                const input = document.querySelector(`input[data-entity="${tableBodyId}"][data-key="${f.key}"]`);
                if (input) {
                    itemData[f.key] = input.value.trim();
                }
            });

            const missingRequired = fields.some(f => !itemData[f.key] && f.key !== 'phone');
            if (missingRequired) {
                alert('Please fill in all required fields.');
                return;
            }

            const res = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(itemData)
            });

            if (res.ok) {
                fetchAndRenderTable(endpoint, tableBodyId, fields);
            } else {
                alert('Failed to add item.');
            }
        });


        window.onload = () => {
            Object.values(tableConfigs).forEach(({ endpoint, tableBodyId, fields }) => {
                fetchAndRenderTable(endpoint, tableBodyId, fields);
            });
        };

    </script>
</body>
</html>
