<!DOCTYPE html>
<html>
<head>
    <title>CRUD Tables</title>
    <style>
        /* Your existing CSS */
    </style>
</head>
<body>
    <h2>Publishers</h2>
    <table>
        <thead>
            <tr>
                <th>Publisher ID</th>
                <th>Publisher Name</th>
                <th>Email</th>
                <th>Phone</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody id="publisherTableBody"></tbody>
    </table>

    <h2>Subjects</h2>
    <table>
        <thead>
            <tr>
                <th>Subject ID</th>
                <th>Subject Name</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody id="subjectTableBody"></tbody>
    </table>

    <h2>Authors</h2>
    <table>
        <thead>
            <tr>
                <th>Author ID</th>
                <th>Author Name</th>
                <th>Email</th>
                <th>Phone</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody id="authorTableBody"></tbody>
    </table>

    <h2>Titles</h2>
    <table>
        <thead>
            <tr>
                <th>Title ID</th>
                <th>Title</th>
                <th>Publisher ID</th>
                <th>Subject ID</th>
                <th>Publication Date</th>
                <th>Cover</th>
                <th>Price</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody id="titleTableBody"></tbody>
    </table>

    <h2>Title Authors</h2>
    <table>
        <thead>
            <tr>
                <th>Title ID</th>
                <th>Author ID</th>
                <th>Importance</th>
                <th>Actions</th>
            </tr>
        </thead>
        <tbody id="titleAuthorTableBody"></tbody>
    </table>

    <script>
        const tableConfigs = {
            publishers: {
                endpoint: '/publishers',
                tableBodyId: 'publisherTableBody',
                fields: [
                    { key: 'pubID', type: 'number', label: 'Publisher ID', isKey: true},
                    { key: 'pname', type: 'text', label: 'Publisher Name' },
                    { key: 'email', type: 'email', label: 'Email' },
                    { key: 'phone', type: 'tel', label: 'Phone' }
                ]
            },
            subjects: {
                endpoint: '/subjects',
                tableBodyId: 'subjectTableBody',
                fields: [
                    { key: 'subID', type: 'text', label: 'Subject ID', isKey: true},
                    { key: 'sName', type: 'text', label: 'Subject Name' }
                ]
            },
            authors: {
                endpoint: '/authors',
                tableBodyId: 'authorTableBody',
                fields: [
                    { key: 'auID', type: 'number', label: 'Author ID', isKey: true},
                    { key: 'aName', type: 'text', label: 'Author Name' },
                    { key: 'email', type: 'email', label: 'Email' },
                    { key: 'phone', type: 'tel', label: 'Phone' }
                ]
            },

            titles: {
                endpoint: '/titles',
                tableBodyId: 'titleTableBody',
                fields: [
                    { key: 'titleID', type: 'number', label: 'Title ID', isKey: true},
                    { key: 'title', type: 'text', label: 'Title' },
                    { key: 'pubID', type: 'number', label: 'Publisher ID' },
                    { key: 'subID', type: 'text', label: 'Subject ID' },
                    { key: 'pubDate', type: 'date', label: 'Publication Date' },
                    { key: 'cover', type: 'text', label: 'Cover' },
                    { key: 'price', type: 'number', label: 'Price' }
                ]
            },

            titleauthors: {
                endpoint: '/titleauthors',
                tableBodyId: 'titleAuthorTableBody',
                fields: [
                    { key: 'titleID', type: 'number', label: 'Title ID', isKey: true },
                    { key: 'auID', type: 'number', label: 'Author ID', isKey: true },
                    { key: 'importance', type: 'number', label: 'Importance' }
                ],  
                compositekey: ['titleID', 'auID']
            }

        };
        function createEditableCell(endpoint, ID, field, value) {
            return `
                <td>
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <span class="display-text">${value}</span>
                        <input class="edit-input" type="text" value="${value}" style="display: none;"
                            data-endpoint="${endpoint}" data-id="${encodeURIComponent(JSON.stringify(ID))}" data-field="${field}"
                            onblur="finishEdit(this)" onkeydown="handleKey(event, this)">
                        <button class="edit-btn" onclick="startEdit(this)" 
                            style="background: none; border: none; cursor: pointer;">✏️</button>
                    </div>
                </td>
            `;
        }

        function startEdit(button) {
            const td = button.closest('td');
            td.querySelector('.display-text').style.display = 'none';
            const input = td.querySelector('.edit-input');
            input.style.display = 'inline';
            input.focus();
        }

        function finishEdit(input) {
            const td = input.closest('td');
            const newValue = input.value.trim();
            td.querySelector('.display-text').textContent = newValue;
            td.querySelector('.display-text').style.display = 'inline';
            input.style.display = 'none';

            // Decode and parse the composite ID (or fallback to single ID)
            let id;
            try {
                id = JSON.parse(decodeURIComponent(input.dataset.id));
            } catch (e) {
                id = input.dataset.id; // fallback for single keys
            }

            updateCell(input.dataset.endpoint, id, input.dataset.field, newValue);
        }


        function handleKey(event, input) {
            if (event.key === 'Enter') {
                input.blur();
            } else if (event.key === 'Escape') {
                const td = input.closest('td');
                input.value = td.querySelector('.display-text').textContent;
                input.style.display = 'none';
                td.querySelector('.display-text').style.display = 'inline';
            }
        }

        async function updateCell(endpoint, keys, field, value) {
            let url = endpoint;

            if (typeof keys === 'object') {
                const keyValues = Object.values(keys);
                url += `/${keyValues.join('/')}`;
            } else {
                url += `/${keys}`;
            }

            const res = await fetch(url, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ field, value }),
            });

            if (!res.ok) {
                alert('Failed to update.');
            }
        }


        async function fetchAndRenderTable(endpoint, tableBodyId, fields) {
            const res = await fetch(endpoint);
            const data = await res.json();
            const tbody = document.getElementById(tableBodyId);
            tbody.innerHTML = '';

            data.forEach(item => {
                const row = document.createElement('tr');

                const keys = {};
                fields.forEach(f => {
                    if (f.isKey) keys[f.key] = item[f.key];
                });

                row.innerHTML = fields.map(f =>
                    createEditableCell(endpoint, keys, f.key, item[f.key] || '')
                ).join('');

                const actionCell = document.createElement('td');
                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = 'Delete';
                deleteBtn.onclick = () =>
                    deleteItem(endpoint, keys, () => fetchAndRenderTable(endpoint, tableBodyId, fields));
                actionCell.appendChild(deleteBtn);

                row.appendChild(actionCell);
                tbody.appendChild(row);
            });


            const newRow = document.createElement('tr');
            newRow.innerHTML = fields.map(f => {
                // Use input fields, empty values, data attributes for add
                return `<td><input type="${f.type}" id="${tableBodyId}-${f.key}" data-entity="${tableBodyId}" data-key="${f.key}" /></td>`;
            }).join('');

            // Add a cell for the add button
            const addCell = document.createElement('td');
            const addBtn = document.createElement('button');
            addBtn.textContent = 'Add';
            addBtn.classList.add('add-btn');
            addBtn.dataset.entity = tableBodyId;
            addCell.appendChild(addBtn);

            newRow.appendChild(addCell);
            tbody.appendChild(newRow);
        }



       async function deleteItem(endpoint, keys, refreshFn) {
            let url;

            if (typeof keys === 'object') {
                // for single keys in object, extract the value and use path param:
                const keyValues = Object.values(keys);
                if (keyValues.length === 1) {
                    url = `${endpoint}/${keyValues[0]}`;
                } else {
                    // handle composite keys (more than one) with slash-separated params
                    url = `${endpoint}/${keyValues.join('/')}`;
                }
            } else {
                url = `${endpoint}/${keys}`;
            }
            const res = await fetch(url, { method: 'DELETE' });
            if (res.ok) refreshFn();
            else alert('Failed to delete item.');
        }



        async function addItem(endpoint, fields, fetchFunction) {
            const itemData = {};

            // Extract values from input fields
            for (const field of fields) {
                const element = document.getElementById(field);
                if (element) {
                    itemData[field] = element.value.trim();
                }
            }

            const res = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(itemData),
            });

            if (res.ok) {
                fetchFunction(); 
            } else {
                alert(`Failed to add item to ${endpoint}.`);
            }
        }

        document.addEventListener('click', async function (e) {
            if (!e.target.classList.contains('add-btn')) return;

            const tableBodyId = e.target.dataset.entity;
            const config = Object.values(tableConfigs).find(cfg => cfg.tableBodyId === tableBodyId);
            if (!config) return;

            const { endpoint, fields } = config;
            const itemData = {};

            fields.forEach(f => {
                const input = document.querySelector(`input[data-entity="${tableBodyId}"][data-key="${f.key}"]`);
                if (input) {
                    itemData[f.key] = input.value.trim();
                }
            });

            const missingRequired = fields.some(f => !itemData[f.key] && f.key !== 'phone');
            if (missingRequired) {
                alert('Please fill in all required fields.');
                return;
            }

            const res = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(itemData)
            });

            if (res.ok) {
                fetchAndRenderTable(endpoint, tableBodyId, fields);
            } else {
                alert('Failed to add item.');
            }
        });


        window.onload = () => {
            Object.values(tableConfigs).forEach(({ endpoint, tableBodyId, fields }) => {
                fetchAndRenderTable(endpoint, tableBodyId, fields);
            });
        };

    </script>
</body>
</html>
