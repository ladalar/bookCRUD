<!DOCTYPE html>
<html>
<head>
    <title>CRUD Tables</title>
    <style>
        .circle-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background-color: #e9f5ff;
            border: none;
            color: #28a745;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .circle-btn:hover {
            background-color: #d4edda;
            transform: scale(1.1);
        }

        .circle-btn:active {
            transform: scale(0.95);
        }

        .delete-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background-color: #e9f5ff;
            border: none;
            color: #d30404;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .delete-btn:hover {
            background-color: #edd4d4;
            transform: scale(1.1);
        }

        .delete-btn:active {
            transform: scale(0.95);
        }
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            margin-bottom: 30px;
            font-family: 'Segoe UI', sans-serif;
            background-color: #f9fcff;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        }

        thead {
            background-color: #e9f5ff;
        }

        thead th {
            padding: 12px 10px;
            font-weight: 600;
            color: #333;
            text-align: left;
            border-bottom: 1px solid #d6eaf8;
        }

        tbody td {
            padding: 10px;
            border-bottom: 1px solid #eef3f9;
        }

        tbody tr:hover {
            background-color: #f0f8ff;
        }

        input[type="text"],
        input[type="email"],
        input[type="number"],
        input[type="tel"],
        input[type="date"] {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ccddee;
            border-radius: 6px;
            font-size: 14px;
            box-sizing: border-box;
        }

        h2 {
            font-family: 'Segoe UI', sans-serif;
            color: #22577a;
            margin-top: 40px;
        }

        .edit-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background-color: #f0f8ff;
            border: none;
            color: #22577a;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-left: auto;
        }

        .edit-btn:hover {
            background-color: #bfd3e8;
            transform: scale(1.1);
        }

        .edit-btn:active {
            transform: scale(0.95);
        }

        th .sort-icon {
            font-size: 0.8em;
            margin-left: 4px;
            opacity: 0.4;
        }

        th.sorted-asc .sort-icon::after {
            content: " ▲";
            opacity: 1;
        }

        th.sorted-desc .sort-icon::after {
            content: " ▼";
            opacity: 1;
        }

        body {
            margin: 0;
            font-family: Arial, sans-serif;
        }

        .navbar {
            background-color: #2c3e50;
            overflow: hidden;
            display: flex;
            align-items: center;
            padding: 0 20px;
        }

        .navbar a {
            color: #ecf0f1;
            padding: 14px 20px;
            text-decoration: none;
            display: block;
        }

        .navbar a:hover {
            background-color: #34495e;
        }

        .navbar .brand {
            font-size: 20px;
            font-weight: bold;
        }

        .navbar .nav-links {
            margin-left: auto;
            display: flex;
        }


    </style>
</head>

<body>
    <div class="navbar">
        <div class="brand">Tables</div>
        <div class="nav-links">
            <a href="index">Tables</a>
            <a href="dash">Dashboard</a>
        </div>
    </div>

    <h2>Publishers</h2>
    <table>
        <thead data-table="publisherTableBody">
            <tr></tr>
        </thead>
        <tbody id="publisherTableBody"></tbody>
    </table>

    <h2>Subjects</h2>
    <table>
        <thead data-table="subjectTableBody">
            <tr></tr>
        </thead>
        <tbody id="subjectTableBody"></tbody>
    </table>

    <h2>Authors</h2>
    <table>
        <thead data-table="authorTableBody">
            <tr></tr>
        </thead>
        <tbody id="authorTableBody"></tbody>
    </table>

    <h2>Titles</h2>
    <table>
        <thead data-table="titleTableBody">
            <tr></tr>
        </thead>
        <tbody id="titleTableBody"></tbody>
    </table>

    <h2>Title Authors</h2>
    <table>
        <thead data-table="titleAuthorTableBody">
            <tr></tr>
        </thead>
        <tbody id="titleAuthorTableBody"></tbody>
    </table>

</body>
    <script>
        const sortStates = {}; 
        const tableConfigs = {
            publishers: {
                endpoint: '/publishers',
                tableBodyId: 'publisherTableBody',
                fields: [
                    { key: 'pubID', type: 'number', label: 'Publisher ID', isKey: true},
                    { key: 'pname', type: 'text', label: 'Publisher Name' },
                    { key: 'email', type: 'email', label: 'Email' },
                    { key: 'phone', type: 'tel', label: 'Phone' }
                ]
            },
            subjects: {
                endpoint: '/subjects',
                tableBodyId: 'subjectTableBody',
                fields: [
                    { key: 'subID', type: 'text', label: 'Subject ID', isKey: true},
                    { key: 'sName', type: 'text', label: 'Subject Name' }
                ]
            },
            authors: {
                endpoint: '/authors',
                tableBodyId: 'authorTableBody',
                fields: [
                    { key: 'auID', type: 'number', label: 'Author ID', isKey: true},
                    { key: 'aName', type: 'text', label: 'Author Name' },
                    { key: 'email', type: 'email', label: 'Email' },
                    { key: 'phone', type: 'tel', label: 'Phone' }
                ]
            },

            titles: {
                endpoint: '/titles',
                tableBodyId: 'titleTableBody',
                fields: [
                    { key: 'titleID', type: 'number', label: 'Title ID', isKey: true},
                    { key: 'title', type: 'text', label: 'Title' },
                    { key: 'pubID', type: 'number', label: 'Publisher ID' },
                    { key: 'subID', type: 'text', label: 'Subject ID' },
                    { key: 'pubDate', type: 'date', label: 'Publication Date' },
                    { key: 'cover', type: 'text', label: 'Cover' },
                    { key: 'price', type: 'number', label: 'Price' }
                ]
            },

            titleauthors: {
                endpoint: '/titleauthors',
                tableBodyId: 'titleAuthorTableBody',
                fields: [
                    { key: 'titleID', type: 'number', label: 'Title ID', isKey: true },
                    { key: 'auID', type: 'number', label: 'Author ID', isKey: true },
                    { key: 'importance', type: 'number', label: 'Importance' }
                ],  
                compositekey: ['titleID', 'auID']
            }

        };
        function createEditableCell(endpoint, ID, field, value) {
            return `
                <td data-field="${field}">
                    <div style="display: flex; align-items: center; justify-content: space-between; gap: 6px;">
                        <span class="display-text">${value}</span>
                        <input class="edit-input" type="text" value="${value}" style="display: none;"
                            data-endpoint="${endpoint}" data-id="${encodeURIComponent(JSON.stringify(ID))}" data-field="${field}"
                            onblur="finishEdit(this)" onkeydown="handleKey(event, this)">
                        <button class="edit-btn" onclick="startEdit(this)" 
                            style="background: none; border: none; cursor: pointer;">🖉</button>
                    </div>
                </td>
            `;
        }

        function startEdit(button) {
            const td = button.closest('td');
            td.querySelector('.display-text').style.display = 'none';
            const input = td.querySelector('.edit-input');
            input.style.display = 'inline';
            input.focus();
        }

        function finishEdit(input) {
            if (!confirm('Save changes?')) {
                input.blur();
                return;
            }
            const td = input.closest('td');
            const newValue = input.value.trim();
            td.querySelector('.display-text').textContent = newValue;
            td.querySelector('.display-text').style.display = 'inline';
            input.style.display = 'none';

            // Decode and parse the composite ID (or fallback to single ID)
            let id;
            try {
                id = JSON.parse(decodeURIComponent(input.dataset.id));
            } catch (e) {
                id = input.dataset.id; // fallback for single keys
            }

            updateCell(input.dataset.endpoint, id, input.dataset.field, newValue);
        }


        function handleKey(event, input) {
            if (event.key === 'Enter') {
                input.blur();
            } else if (event.key === 'Escape') {
                const td = input.closest('td');
                input.value = td.querySelector('.display-text').textContent;
                input.style.display = 'none';
                td.querySelector('.display-text').style.display = 'inline';
            }
        }

        async function updateCell(endpoint, keys, field, value) {
            let url = endpoint;

            if (typeof keys === 'object') {
                const keyValues = Object.values(keys);
                url += `/${keyValues.join('/')}`;
            } else {
                url += `/${keys}`;
            }

            const res = await fetch(url, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ field, value }),
            });

            if (!res.ok) {
                alert('Failed to update.');
            }
        }


        async function fetchAndRenderTable(endpoint, tableBodyId, fields) {
        let data = [];

        try {
            const res = await fetch(endpoint);
            if (!res.ok) {
                console.warn(`Fetch failed for ${endpoint}, using mock data.`);
            } else {
                data = await res.json();
            }
        } catch (e) {
            console.warn(`Fetch error for ${endpoint}, using mock data.`, e);
        }

        // If no data fetched, provide mock data for testing filtering:
        if (!data.length) {
            if (tableBodyId === 'publisherTableBody') {
                data = [
                    { pubID: 1, pname: "Willey Publishing", email: "contact@willey.com", phone: "123-456-7890" },
                    { pubID: 2, pname: "Smith & Co", email: "info@smithco.com", phone: "987-654-3210" },
                    { pubID: 3, pname: "BooksRUs", email: "hello@booksrus.com", phone: "555-123-4567" }
                ];
            } else if (tableBodyId === 'subjectTableBody') {
                data = [
                    { subID: "S01", sName: "Mathematics" },
                    { subID: "S02", sName: "Literature" }
                ];
            } else if (tableBodyId === 'authorTableBody') {
                data = [
                    { auID: 1, aName: "Alice Johnson", email: "alice@example.com", phone: "111-222-3333" },
                    { auID: 2, aName: "Bob Smith", email: "bob@example.com", phone: "444-555-6666" }
                ];
            } else if (tableBodyId === 'titleTableBody') {
                data = [
                    { titleID: 1, title: "Intro to Programming", pubID: 1, subID: "S01", pubDate: "2020-01-01", cover: "Soft", price: 29.99 },
                    { titleID: 2, title: "World History", pubID: 2, subID: "S02", pubDate: "2019-06-15", cover: "Hard", price: 39.99 }
                ];
            } else if (tableBodyId === 'titleAuthorTableBody') {
                data = [
                    { titleID: 1, auID: 1, importance: 1 },
                    { titleID: 2, auID: 2, importance: 2 }
                ];
            }
        }

        const tbody = document.getElementById(tableBodyId);
        tbody.innerHTML = '';

        data.forEach(item => {
            const row = document.createElement('tr');

            const keys = {};
            fields.forEach(f => {
                if (f.isKey) keys[f.key] = item[f.key];
            });

            row.innerHTML = fields.map(f =>
                createEditableCell(endpoint, keys, f.key, item[f.key] || '')
            ).join('');

            const actionCell = document.createElement('td');
            const deleteBtn = document.createElement('button');
            deleteBtn.innerHTML = '-';
            deleteBtn.classList.add('delete-btn');

            deleteBtn.onclick = () =>
                deleteItem(endpoint, keys, () => fetchAndRenderTable(endpoint, tableBodyId, fields));
            actionCell.appendChild(deleteBtn);

            row.appendChild(actionCell);
            tbody.appendChild(row);
        });

        // Also append the "new item" input row as before
        const newRow = document.createElement('tr');
        newRow.innerHTML = fields.map(f => {
            return `<td><input type="${f.type}" id="${tableBodyId}-${f.key}" data-entity="${tableBodyId}" data-key="${f.key}" /></td>`;
        }).join('');

        const addCell = document.createElement('td');
        const addBtn = document.createElement('button');
        addBtn.innerHTML = '+';
        addBtn.classList.add('add-btn', 'circle-btn');
        addBtn.dataset.entity = tableBodyId;
        addCell.appendChild(addBtn);

        newRow.appendChild(addCell);
        tbody.appendChild(newRow);
    }

       async function deleteItem(endpoint, keys, refreshFn) {
            if (!confirm("Are you sure you want to delete this item?")) return;
            let url;

            if (typeof keys === 'object') {
                // for single keys in object, extract the value and use path param:
                const keyValues = Object.values(keys);
                if (keyValues.length === 1) {
                    url = `${endpoint}/${keyValues[0]}`;
                } else {
                    // handle composite keys (more than one) with slash-separated params
                    url = `${endpoint}/${keyValues.join('/')}`;
                }
            } else {
                url = `${endpoint}/${keys}`;
            }
            const res = await fetch(url, { method: 'DELETE' });
            if (res.ok) refreshFn();
            else alert('Failed to delete item.');
        }


        async function addItem(endpoint, fields, fetchFunction) {
            const itemData = {};

            // Extract values from input fields
            for (const field of fields) {
                const element = document.getElementById(field);
                if (element) {
                    itemData[field] = element.value.trim();
                }
            }

            const res = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(itemData),
            });

            if (res.ok) {
                fetchFunction(); 
            } else {
                alert(`Failed to add item to ${endpoint}.`);
            }
        }

        document.addEventListener('click', async function (e) {
            if (!e.target.classList.contains('add-btn')) return;

            const tableBodyId = e.target.dataset.entity;
            const config = Object.values(tableConfigs).find(cfg => cfg.tableBodyId === tableBodyId);
            if (!config) return;

            const { endpoint, fields } = config;
            const itemData = {};

            fields.forEach(f => {
                const input = document.querySelector(`input[data-entity="${tableBodyId}"][data-key="${f.key}"]`);
                if (input) {
                    itemData[f.key] = input.value.trim();
                }
            });

            const missingRequired = fields.some(f => !itemData[f.key] && f.key !== 'phone');
            if (missingRequired) {
                alert('Please fill in all required fields.');
                return;
            }

            const res = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(itemData)
            });

            if (res.ok) {
                fetchAndRenderTable(endpoint, tableBodyId, fields);
            } else {
                alert('Failed to add item.');
            }
        });

        function filterTable(tableBodyId, searchValue) {
            const tbody = document.getElementById(tableBodyId);
            const rows = tbody.querySelectorAll('tr');

            const lowerSearch = searchValue.toLowerCase();

            // The last row is always the input row, so we don't filter it.
            for (let i = 0; i < rows.length - 1; i++) {
                const row = rows[i];
                const cells = Array.from(row.querySelectorAll('td'));
                const text = cells.map(cell => cell.textContent || '').join(' ').toLowerCase();
                const matched = text.includes(lowerSearch);

                row.style.display = matched ? '' : 'none';
            }
        }


        function createSearchInputs() {
            console.log('createSearchInputs running');
            Object.values(tableConfigs).forEach(({ tableBodyId }) => {
                const tbody = document.getElementById(tableBodyId);
                const table = tbody.closest('table');

                if (!table.parentNode.querySelector('.search-container[data-table="' + tableBodyId + '"]')) {
                    const div = document.createElement('div');
                    div.className = 'search-container';
                    div.setAttribute('data-table', tableBodyId);

                    const input = document.createElement('input');
                    input.type = 'text';
                    input.placeholder = `Search...`;

                    input.addEventListener('input', () => {
                        filterTable(tableBodyId, input.value);
                    });

                    div.appendChild(input);
                    table.parentNode.insertBefore(div, table);
                }
            });
        }

        function sortTableByColumn(tableBodyId, fields, columnKey) {
            const tbody = document.getElementById(tableBodyId);
            const rows = Array.from(tbody.querySelectorAll('tr')).slice(0, -1); // exclude input row

            const field = fields.find(f => f.key === columnKey);
            if (!field) return;

            const type = field.type;
            const sortKey = `${tableBodyId}-${columnKey}`;
            sortStates[sortKey] = !sortStates[sortKey]; // toggle sort direction
            const ascending = sortStates[sortKey];

            rows.sort((a, b) => {
                const aText = a.querySelector(`[data-field="${columnKey}"] .display-text`)?.textContent.trim() || '';
                const bText = b.querySelector(`[data-field="${columnKey}"] .display-text`)?.textContent.trim() || '';
                let aVal = aText, bVal = bText;

                if (type === 'number') {
                    aVal = parseFloat(aVal);
                    bVal = parseFloat(bVal);
                } else if (type === 'date') {
                    aVal = new Date(aVal);
                    bVal = new Date(bVal);
                } else {
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                }

                if (aVal < bVal) return ascending ? -1 : 1;
                if (aVal > bVal) return ascending ? 1 : -1;
                return 0;
            });

            rows.forEach(row => tbody.insertBefore(row, tbody.lastChild));

            // 🔁 Update sort icons
            const headerRow = document.querySelector(`thead[data-table="${tableBodyId}"] tr`);
            headerRow.querySelectorAll('th').forEach(th => {
                th.classList.remove('sorted-asc', 'sorted-desc');
                if (th.dataset.key === columnKey) {
                    th.classList.add(ascending ? 'sorted-asc' : 'sorted-desc');
                }
            });
        }

        function addSortingHeaders() {
            Object.values(tableConfigs).forEach(({ tableBodyId, fields }) => {
                const theadRow = document.querySelector(`thead[data-table="${tableBodyId}"] tr`);
                if (!theadRow) return;

                theadRow.innerHTML = '';

                fields.forEach(f => {
                    const th = document.createElement('th');
                    th.dataset.key = f.key;
                    th.innerHTML = `<span class="sortable-header">${f.label} <span class="sort-icon">⇅</span></span>`;
                    th.style.cursor = 'pointer';
                    th.addEventListener('click', () => sortTableByColumn(tableBodyId, fields, f.key));
                    theadRow.appendChild(th);
                });

                const actionTh = document.createElement('th');
                actionTh.textContent = 'Actions';
                theadRow.appendChild(actionTh);
            });
        }




        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM fully loaded and parsed');
            Object.values(tableConfigs).forEach(({ endpoint, tableBodyId, fields }) => {
                fetchAndRenderTable(endpoint, tableBodyId, fields);
            });
            createSearchInputs();
            addSortingHeaders(); 
        });




    </script>
</body>
</html>
